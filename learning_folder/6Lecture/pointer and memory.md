### Про статический массив:

Для статического массива нехорошо делать размер не константу, потому что некоторые компилляторы требуют, чтобы размер статического массива был известен на момент
входа в функцию.


### про RAM:

РАМ - это массив байтов

Отличие памяти с произвольным доступом (RAM) от, например, хдд в том, что в рам обращение к любому байту происходит за одно и то же время, а в хдд доступ к памяти последовательный.

.flat модель памяти используется при простой разработке - все байты просто растянуты в одну ленту и пронумерованы

В момент запуска .out у нас выделяется память 

## Указатели.

- Ссылка:
удобство ссылки в том, что с ссылкой на инт мы обращаемся так же как с самим интом - то есть через ссылку мы под копотом берем адрес, потом значение, лежащее по этому адресу меняем,

- Указатель:
указатель это же как раз-таки именно ячейка памяти и нам надо вручную прописывать все манипуляции с получением значения и прочее

По сути это тип переменной, которая указывает на адрес ячейки памяти

"&" - унарный оператор взятия адреса; - применяется не к указательному типу для получения адреса (возвращает указатель на тип данных)

"*" - унарный оператор получения значения (операция разыменования) - применяется к указательному типу для получения значения (возвращает сам тип данных)

```cpp
int x = 1, y = 2;
int *ip;    // инициализируем тип - указатель на инт
ip = &x;    // теперь ip хранит в себе указатель на ячейку памяти, где хранится значение x

y = *ip     // мы разыменовали ip - получили значение из указателя; мы обращаемся к тому, что лежит в ячейке ip

*ip = 0     // мы изменили значение, лежащее в ячейке памяти, отвечающее переменной x, теперь x - это 0
```

Статический массив - это статический указатель на свой 0 элемент

Адресная арифметика - это тот самый прикол с массивами статическими

Значение указателя же тоже должно где-то хранится, поэтому можно создать указатель на указатель

## Модель памяти

При запуске у нас выделяется память для глобальных переменных, а потом при заходе в каждую функцию мы инициализируем стек локальных переменных и по нему прыгаем, каждая новая локальная переменная добавляется в стек локальных переменных, но суть в том, что стек локальных переменных не очищается

## Передача в функцию по указателю:

```cpp

void incr(int *x_pointer)
'''функция, которая увеличивает лежащее в ячейке памяти значение на 1,
то есть мы можем и из другой функции это вызывать, чтобы изменять значение локальной переменной
'''
{
    *(x_pointer) += 1;      // увеличиваем именно значение лежащее в ячейке памяти на 1
}

int main()
{
    int x = 1;
    incr(&x);
    // x теперь 2
    return 0;
}

```

## Устройство памяти. (heap и stack локальных переменных)

Вся память для программы делится на 4 части:
- data - глобальные переменные
- text - текст самого кода
- stack - стек локальных переменных, у него очень маленький объем около (8 MB) - здесь хранятся локальные переменные и параметры функций
- heap (куча) - сегмент, который умеет динамически менять размер (это динамическая память)

В куче выделяем память при помощи new:
```cpp

int* p = new int;   // new возвращает нам адрес, то есть мы присваиваем указателю ячейку памяти из кучи
delete p;   // убираем выделенную в куче память

```

Если мы создаем локальную переменную, то она попадает на стек локальных переменных, но если мы хотим создать что-то очень жирное, то
это уже надо помещть в кучу через n и просо уже работаем дальше как обычно, просто выделяем немного другой участок памяти.

Так вот, если мы хотим создать массив не с константным размером, то его уже надо инициализировать через new - это динамическая память:

```cpp

std::cin >> n;
int* p = new int[n];    // мы производим инициализацию динамического массива

delete[] p
```

Если че, то элементы вектора хранятся в heap(то есть вектор вызывает new и delete сам) и delete тоже вызывется, вообще все std контейнеры хранят значения в heap

Можно использовать valgrind для отладки ошибок связанных с памятью