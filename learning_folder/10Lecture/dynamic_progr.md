# Динамическое программирование

"Словосочетание «динамическое программирование» впервые было использовано в 1940-х годах Ричардом Беллманом для описания процесса нахождения решения задачи, где ответ на одну задачу может быть получен только после решения задачи, «предшествующей» ей."

Разделение задачи на подзадачи или вычисление всех необходимых тривиальных подзадач и их соединение:

- Нисходящее ДМ - разделение на подзадачи рекурсивно

- Восходящее ДМ - вычисление всех необходимых подзадач и потом конструирование решения

Мемоизация - https://youtu.be/rmycFp0aWNY?t=371 - сохранение результатов вычисления какой либо подзадачи, чтобы ее дважды не считать,
(естесна это работает только для функций, которые всегда одинаково работают при одинаковых параметрах)

Пример: https://youtu.be/rmycFp0aWNY?t=559

## Задача о наибольшей общей подпоследовательности

Тут подпоследовательность - то же что в матане: чтобы порядок у элементов был такой же, не обязательно чтобы подряд шли (это не поиск подстроки)

https://youtu.be/rmycFp0aWNY?t=2445 - решение восходящим методом.

У него в коде: 0 по умолчанию в массиве из значений функции от длин подпоследовательностей, а когда мы обратились к какой-то длине, то туда 1 ставим, поэтому из результата функции надо будет всегда 1 вычитать

В двумерном массиве хранятся максимальные длины подпоследовательностей для наших изначальных последовательностей, но меньшего размера: https://youtu.be/rmycFp0aWNY?t=3100 - он на доске пояснил,

https://youtu.be/rmycFp0aWNY?t=4118 - решение восходящим методом

Но хранить всю матрицу не обязательно - можно две строки лишь хранить

## Задача о размене (не обязательно каноническая система монет)

https://youtu.be/rmycFp0aWNY?t=4715

Из нужной суммы просто вычитаем по одной монете каждого номинала, получая: L1,..,Ln - нужная сумма без монеты n номинала. 