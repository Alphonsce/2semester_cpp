## Деревья.

В дереве у каждого элемента может быть несколько указатлей на слудующие

У каждого элемента есть ровно 1 родительский элемент, кроме корневого элемента, то есть на каждый элемент ссылается только 1 элемент.

Листовой элемент - который не является родительским ни для какого

```cpp

struct Tree {
    Tree** subtrees;    // если просто указатель хранить, то это указатель на 1 структуру поддерева, нам надо хранить массив указателей на поддеревья
    std::size_t size    // размер в памяти
    int data;       // что-то, что лежит в родительской вершине текущего дерева
}

```

Бинарное дерево - у каждого не более 2 дочерних.

У него ровно 2 связи:

```cpp

struct Tree {
    Tree* left;    // правое поддерево
    Tree* right;    // левое поддерево
    std::size_t size    // размер в памяти
    int data;       // что-то, что лежит в родительской вершине текущего дерева
}

```

Как обойти все дерево??? 

https://youtu.be/mOoPFAuwhaI?t=1236

**Высота дерева** - количество свзяей от корня до листа.

Простой путь - если мы посещаем каждый узел лишь 1 раз - высота дерева тогда - длина самого длинного простого пути

## Бинарное дерево поиска.

https://youtu.be/mOoPFAuwhaI?t=2205

$$
N = 2^H - 1
$$

Если для всех листьев одинаковый путь, то N - число листьев. 

- Тогда добавление элемента в дерево поиска займет O(log N), добавляем просто листом.

- Удаление элемента:
если смотреть на дерево, то элементы слева направо расположены по убыванию: чем левее - тем больше, чем правее - тем меньше

swap делаем просто для элемента который на вырезать с элементом, который самый близкий к нему - либо слева, либо справа: https://youtu.be/mOoPFAuwhaI?t=2904

https://youtu.be/mOoPFAuwhaI?t=2492

Вырожденное дерево - один длинный отсортированный список - то есть просто одна прямо идущая ветка.

**Если элементы поступают отсортированные, то просто использовать дерево поиска нормально не получится, потому что тогда $H\approx N$ и формула наша с логарифмом вообще неверна и сложность вставки тогда как просто вставка в отсортированный list**

Можно рандомизировать ввод данных некоторым образом так, чтобы все было норм.

Так или иначе мы будем стакливаться с задачей балансировки дерева поиска, чтобы из походего на список его превращать ближе к идельному дереву, где длина каждого пути к листу одинаковая - тогда наши вставки за логарифм работают.

### Балансировка бинарного дерева.

1) левый поворот: https://youtu.be/mOoPFAuwhaI?t=3586

2) правый поворот: https://youtu.be/mOoPFAuwhaI?t=3721

АВЛ дерево - для каждого родительского класса разница между высотами левого и правого поддеревьев 0 или 1 или -1

При добавлении оно всегда будет за 2 поворота балансироваться